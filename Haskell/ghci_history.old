:doc (div)
:doc (&&)
:t error
isLeapYear 2016
:doc sequence_
mapM_ putStrLn [(1,2), (2,3)]
let data = [(1,2), (2,3)]
data = [(1,2), (2,3)]
let data = [(1,2), (2,3)]
let data = [(1,2), (2,3)]
data = [(1,2), (2,3)]
[(1,2), (2,3)]
:doc mapM
:doc mapM_
mapM_ putStrLn(show(fst x) ++ " " ++ show(snd x) ++ "\n") [(1,2)]
mapM_ putStrLn(show(fst x) ++ " " ++ show(snd x) ++ "\n") [(1,2])
mapM_ putStrLn(show(fst x) ++ " " ++ show(snd x) ++ "\n") 
x = (1, 2)
mapM_ putStrLn(show(fst x) ++ " " ++ show(snd x) ++ "\n") 
value
value = show(fst x) ++ " " ++ show(snd x) ++ "\n"
:t show
main
main = mapM_ putStrLn ls
ls = [ "banana", "mango", "orange" ]
let data <- show(fst x) ++ " " ++ show(snd x) ++ "\n"
let data = show(fst x) ++ " " ++ show(snd x) ++ "\n"
data = show(fst x) ++ " " ++ show(snd x) ++ "\n"
show(fst x) ++ " " ++ show(snd x) ++ "\n"
show(fst x) ++ show(snd x) ++ "\n"
show(fst x) + show(snd x) + "\n"
fst x + snd x + "\n"
fst x + snd x
fst x
putStrLn (fst x ++ snd x ++ "\n")
x = (1,2)
putStrLn (fst x ++ snd x ++ "\n")
a = [(-4,2),(-3,2),(3,1),(4,1)]
map (++ "x") (fromList [(5,"a"), (3,"b")])
fst (1,2)
fst a
a = [(1,2)]
a = [(1,2])
[(1,2])
print x:xs = fst x ++ " " ++ snd x ++  
:{
a = [(-4,2),(-3,2),(3,1),(4,1)]
main
main
:load 11.hs
fromListWith
:doc fromListWith
import Data.Map.Strict
:doc fromListWith
:doc fromListWith
:t fromListWith
fromListWith
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
fromListWith (+) sortedxss  
count x xss = 
:set +m
count x xss = 
count x =
sortedxss 
sortedxss = [(x, 1) | x <- xss]
[(x, 1) | x <- xss]
xss
xss = sort x
x
[(xs, 1) | xs <- x]
x
x = [1,-5,3,4,-5, 3]
[(i, 1) | i <- [1..10]]
:doc (<-)
  print x
  x <- xs
main = do
print(x <- xs)
x <- xs
[(x, 1) | x <- xs]
xs = [1,2,3,4,1,2,3,4,1,-1]
:doc toList
:doc fromListWith
fromListWith (+) [(a, 1) | a <- x]
[(a,1) |  a <- x]
x = [1,2,3,3,2,1]
xss
[(x,1) | x <- xss]
(!!) xss 0
!! xss 0
xss
xss[0]
xss
xss ! 0
xss !! 0
xss = fromList [(5,"c"), (3,"b"), (5, "a")]
fromList [(5,"c"), (3,"b"), (5, "a")]
import Data.Map.Strict
fromList [(5,"c"), (3,"b"), (5, "a")]
sort a
import Data.List
a = [1,2,3]
xs = "3 -1 -3 5 5 1 3 -4 3 -5 4 2 -2 -3 -5 3 1 4 5 3"
xs
x
b
a
xs
xs = sort xs
import Data.List
xs = sort xs
xs = [1, 2, 3, 3]
c
c = sort a
b
b = sort a
a
a = sort a
a
b
b = sort a
a = [1, 1, 2, 3, 3]
a
a = toList $ fromListWith (+)a 
:t a
a = toList $ fromListWith (+) a
toList $ fromListWith (+) a
toList fromListWith (+) a
fromListWith (+) a
a
a  = [(x, 1) | x <- [1,2,1]]
[(x, 1) | x <- [1,2,1]]
:t fromListWith
main
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
:load 11.hs
import Data.Map.Strict
:t splitOn
:t spliton
import Data.List.Split
:t spliton
import Data.List
sort a
import Data.List
sort a
a = [1, 23, 2]
main
:load 11.hs
:load 11.hs
a
:}
let b = map read $ splitOn " " a :: [Integer] 
:{
b
a
:load 11.hs
:load 11.hs
splitOn " " a
b
:}
let b = map read $ splitOn " " a :: [Integer] 
:{
:{ map read $ splitOn " " a :: [Integer] 
:{ map read $ splitOn " " a :: [Integer] 
:{ map read $ splitOn " " a :: [Integer] :}
map read $ splitOn " " a 
:t splitOn
import Data.List.Split
:t splitOn
:}
a <- getLine :: List[String]
:{
map (a++a) [a]
map (++) [a]
map print [a]
map putStrLn [a]
map putStrLn a
[a]
["appel"]
:t map
:}
:]
:{
a
:t lines
:t read
:t red
:t words
map digitToInt $ filter (/=" ") a
map digitToInt $ filter (/=, " ") a
map digitToInt a
import Data.Char
map read $ a 
map read $ a :: [Int]
a <- getLine
a = "1 2 3"
a
:t a
a <- getLine
:load 11.hs
:load 11.hs
:t getLine
:t List[Int]
:load 11.hs 
:load 11.hs 
main
main
:load 11.hs 
:load 11.hs 
  return (read line :: Int)
  data = getLine
getInt = do
import Data.List.split
split a " "
split a
a = "1 2 3"
:t split
getLine 
:doc Data.Map.lookup
:doc lookup
main
:load map.hs 
main
main
:load map.hs 
:t main
:t main
:load map.hs 
:t main
:t main
:load map.hs 
ls
:doc Char8
:doc B
import qualified Data.ByteString.Char8 as B
ls
:doc replicateM
:t b
:t a
b = Nothing
a = Just 3
Just 3
:doc Maybe
  x <- getLine 
main  = do
read "13" :: Int
:doc read
read "3.3"
:doc getArgs
:doc readFile
readFile "~/bin/kerl" 
readFile "~/bin/kerl" 
writeFile "~/bin/hello.md" "string"
writeFile "~/bin/" "string"
:doc writeFile
writeFile "bing"
:doc  ($)
:doc unlines
:doc Integer
:doc Int
:doc Void
:doc Bool
:doc void
:doc (')
:k (')
:t (')
:doc nub
parse
parse  = read
read
format 4
format 0
:}
format n = show n
format 0 = "INSOMNIA"
format :: Int -> String
:{
format 0
format n = show n
format 0
format 0 = "INSOMNIA"
toInteger a
a
a <- getChar 
toInteger '3'
toInteger "3"
:doc getLine 
elem 1 x
elem "hello" x
x = ["hello", "world"]
elem "jel" x
elem 1 x
elem x 2
elem
x = [1,2]
:doc filterM
const 4 5
const ([True, False])
const [True, False]
:t const
:hoogle Array
:doc A.Array 
A.Array 
A
import qualified Data.Text.Array as A
:doc Data.Array
import Data.Array
:t reverse
abc 
abc  = reverse "abc" 
l
it
x
let x = 34
= 3
x
let
paildrom 3
paildrom [1,2,3]
paildrom [1,2,1]
paildrom x = reverse x == x
if True ((>>) 2) else 4
if True (>>) 2 else 4
if True >> 2 else 4
if True then 2 else 4
import System.Console.Haskeline
import System.Cmd
cpuTimePrecision 
getCPUTime 
import System.CPUTime
main
:load simple.hs 
clear
`<!` = +
infixr 9 `<!`
module Hello where
<! = +
infixr 9 `<!`
module Hello where
<! = +
infixr 9 '<!'
module Hello where
import Prelude
module Main where
max 3 6
max a b = if a > b then a else b
:t forall
x >> 
x
data Maqbool  = mkMaqbool
:t Maqbool 
data Maqbool  = Maqbool
data maqbool  = maqbool
:t A
A
data A = A
4 * 4
(* 4 4)
* 4 4
:doc *
:t *
:k *
import Prelude
Enum 
:k Enum
data Boolean = mkBoolean { True :: Boolean, False :: Boolean}
:t True
:t False
False
1.
1..
1..20
0.1..10
[0.1..2]
0.1..2
0.1 .. 2
:t show 
main = appendFile "squares" (show [(x,x*x) | x <- [0,0.1..2]])
main 
main = appendFile "squares" (show [(x,x*x) | x <- [0,0.1..2]])
"hello"
main = do
:k IO
:t IO
import IO
:t readFile "main.js"
readFile "main.js"
appendFile "main.js" "hello"
appendFile "main.js" "hello"
appendFile "main.js" "hello"
readFile "main.js"
appendFile "main.js" "hello"
readFile "main.js"
ls
readFile "main.js"
readFile "~/main.js"
print "hello"
:t show "hello"
readFile "~/main.js" show("hello")
readFile "~/main.js" "hello"
writeFile "~/app.js" "hello"
import Prelude
isLeapYear 2013
isLeapYear 2012
isLeapYear 2016
isLeapYear 2017
isLeapYear 2018
isLeapYear 2016
show gregorianMonthLength 3
print(gregorianMonthLength 3)
gregorianMonthLength(1)
gregorianMonthLength(10)
gregorianMonthLength()
gregorianMonthLength 
import Data.Time.Calendar
:t a
a
a = undefined
{-- let vs non-let--}
:sprint x
x = 1 :: Int
:sprint u
let u = 2 :: Int
:sprint u
let u = 2
:sprint x
x = 1
:show linker
:?
:/
:ls
ls
)
(+ 1
(+ 1 2)
(+ 1) :: Num a => a -> a
(+ 1) :: Int
"heo" :: String
"heo" :: Strig
3 :: Int
:t it
main
:load main.hs 
:hoogle Foldable
:doc Foldable 
:load main.hs 
4 + 3
\x -> "helo" ++ _
\x -> \x -> _
:1:1-13
\x -> \x -> _
:1:1-13
\x -> \x -> x
hello = "world"
import System.Sound
import Sound
import Sound.
:hoogle System
:hoogle System.Process
:i Process
:doc System.Process
:doc Process
cmdspec 
import System.Process
import System.Process
import System.Cmd 
import Control.Composition
import Control.Composition
import Control.Composition.(~@~)
import Control.Composition(~@~)
:k (~==)
:k (~)
:k (~:)
:t (~)
:t (~:)
:hoogle (~)
:doc (~)
:k (~)
:i (~)
:i (
:t (~)
:t Request
:t getUri 
:t get
get "www.maqbool.net"
get "https://www.maqbool.net"
:load http.hs 
square 3.0
square 3
:t square
:load main.hs 
:t 3
:t True
:t Bool
:t Integer
Int
Int 4
data Maybe a = Nothing | Just a
data Point a = Point a a 
data Bool = True | False
              | Just a  -- ...unary data constructor
 data Maybe a = Nothing -- ...nullary data constructor
 -- non-nullary type constructor with...
 data Point a = Point a a
 -- non-nullary type constructor with one non-nullary data constructor
           | True
 data Bool = False
 -- nullary type constructor with two nullary data constructors
(!!6) $ scanl (*) 1 [1..]
:instances
:doc Enum
[1..4]
:doc length
:hoogle length
:hoogle map
Just 4 == Just 4
data Maybe a = Nothing | Just a deriving (Show, Eq)
Just 4 == Just 4
b
b = Just 4
a
a = Nothing
data Maybe a = Nothing | Just a deriving (Show)
b
b = Nothing
:t a
a
a = Just 3
Just 3
Nothing
data Maybe a = Nothing | Just a
:i Functor 
:k Functor 
:t  Functor 
  fmap :: (a -> b) -> f a -> f b
class Functor f where 
import System.IO(getChar) as x
import System.IO(getChar) AS x
:t getChar
import System.IO(getChar)
import Data.String(Repl(..))
import Data.String(..)
:t Data.String.fromString 
:k Data.String.IsString 
:t Data.String.IsString 
Data.String.IsString 
import Data.String(IsString(..))
:i []
:i IO
:t IO
:k IO
:k []
:kind Bool
:kind Monad
:kind Maybe
:kind Int
:k 3
id 3 == 3
fmap id 3
id 3
id
:t fmap
fmap
fmap id
:i forall
:type forall
instance Show (Integer -> Integer) x
square "apple"
square a
show a
a
let a = \x -> x +1
a
a
a = \x -> x +1
a = \x = x +1
square square
square True 
square 89
square 4
square "long"
:}
square x = x 
square :: a -> a
:{
:}
square x = x * x
square :: a -> a
:{
id 4 5
id 3
id t x = x 
square 5.0
square 3
square x = x * x
:doc Maybe
:doc Just
:doc Socket
:t Socket
:i Socket
:t Socket
import Network.Socket
import Network.Socket.
import Data.Text
:doc eq
:i Eq
Eq
:doc Eq
import Data.Eq
:hoogle Cookie
:hoogle Cookie
:hoogle Cookie
:doc Cookie
import Web.Cookie 
:doc 
:show targets
:show language 
:show paths
:show modules
:?
:cmd ls
:cmd 
:hoogle import
:doc list
:doc import
:doc import
import Text.PrettyPrint(text)
text "est"
import Text.PrettyPrint 
:hoogle text
:hoogle 
:t Read
Read
 import Data.Text.Read 
:doc import Data.Text.Read 
:doc main
:hoogle main
:t True
:t Boool
Boool
:doc Boool
data Boool  = True | False
:doc Bool
:doc True
:doc Base
:browse! Basement.Bits 
:doc =
:doc ==
:doc do
:doc Integer
:doc Int
:doc Either
:doc Maybe
:doc IO
:hoogle ord
:doc Ord
:doc Eq
:hoogle (+)
:hoogle (+)
:hoogle length
:doc Monad
:doc Monad
:doc Foldable
:doc length
:doc Base
:doc IArray
:doc Array
:doc []
:doc Prelude
t Prelude
:doc map
:hoogle Int->Int
:hoogle Int->Int
--count=20
:hoogle Int->Int
:quit
:quti
:help 
:doc map
:docs map
:hoogle 20 map 
:hoogle --count=10 map 
:hoogle map
:hoogle  map
:t lefts
:t lefts
lefts [lefty]
let eithers = Either 4 | 5
let eithers = Either 4 5
let righty  = Right 10
lefty
:t lefty
let lefty = Left 10
main
main  = print "hello"
> main = print "hello"
2 `subtract` 10
\bar"
"goo\
clear
ls
clear
main
:load main.hs 
:t Control.Monad.mapM
h Control.Monad.mapM
Control.Monad.mapM
import Control.Monad 
  return ()
  number <- getLine "Please enter the number"
main = do
main
  number <- getLine "Please enter the number"
main = do
data IP = IP Word8 Word8 Word8 Word deriving(Show)
putStrLn
:t say
say
  return "hell"
say = do
a
a <- getLine
:t getLine
action
  return ()
  let action = putStrLn "whl"
main = do
:t return
:i do
:k do
:t do
:print main
main
:t main
:t main
main
  putStrLn "Learn Haskell"
  putStrLn "Take a nap"
  putStrLn "Go shopping"
main = do
:t putStrLn 
main 
  putStrLn name
  name <- getLine
main = do
ifile 
ifile <- getLine 
:t (>>)
:t (>>=)
readLn e
readLn 
interact  "apple" "am"
interact 
getChar 
getLine 
:t readDec 
:t showHex
:t readFloat
import Numeric
:t readFloat
:t fromRational 
:i Ix
:t Ix
:t range
:i IO
:k IO
IO
Array [1,2]
:t Array 
a
a = Array (1,2)
Array (1,2)
:t GHC.Arr.Array 
:i GHC.Arr.Array 
h GHC.Arr.Array 
:t GHC.Arr
:t array
array
Data.Array
clear
:t sum
map f = fold (\x xs -> f x : xs) [1,2]
map f = fold (\x xs -> f x : xs) []
if not [] then  "list"
  print("list")
if not []
not []
:type map f 
map f 
map f [1,2]
let f(x)  = x * x
:load summ.hs 
:load summ.hs 
:t sum
:load summ.hs 
:load summ.hs 
:load summ.hs 
:load summ.hs 
it
sum [1,2]
summ [1,2]
summ[x:xs] = x + sum(xs)
:}
summ [x:xs] = x + summ(xs)
summ [] = 0
summ :: [Int] -> Int
:{
4  + 3 :: Int
4 :: Int + 3 :: Int
4 + 3
:t (+)
:t sum
:}
summ [x:xs] = x + summ[xs]
summ [] = 0
summ :: [Num] -> Num
:{
:t sum
sum [3,4]
sum [23,4]
:type sum
3
:t 3
:t Int
:}
summ [x:xs] = x + summ xs
summ [] = 0
summ :: [Int] -> Int
:{
2 + 3
:set +t
summ [1]
summ []
summ [3,4]
:}
sum [x:xs] = x + summ xs
summ [] = 0
summ :: [Int] -> Int
:{
summ [x:xs] = x + summ xs
summ [] = 0
append 3 (append 8 5) == append 8 (append 3 5)
empty 0
empty 3
Integer 3
Int(3)
:t Int
Int
append 1 2
  append a b = a + b
  empty = 0 :: Integer
instance Monoid Integer where 
  append x y = x + y
  empty = 0
instance Monoid Num where
:t (2 + 3)
append 3 4
  append x y = x + y
  empty = 0
instance Monoid Int where 
empyt
empty
empyt = 0
infixr 6 <>
  append x y = x + y
  empty :: 0
instance Monoid Int where
  append :: a -> a -> a
  empty :: a
class Monoid a where 
:i (+++)
3 +++ 2
:}
a+++b =  a + (b `div` 2)
(+++) :: Int -> Int -> Int
:{
:{(+++) :: Int -> Int -> Int
(+++) :: Int -> Int -> Int
:k infixl
:t infixl
infixl 6 +
:i (+)
:type (+)
:type (+++)
:type (--)
:type (++)
:type(++)
40 +++ 20
import           Transient.Base
import Transient.Base
:t (:<|>)
:k (:<|>)
clear
:i Servant.API.DELETE 
:i Servant.API
:i Servant
:t Servant.API.header 
:k ((->))
:k (->)
:load Sitemap.hs 
:load record.hs 
MkPerson "apple" 2
:load record.hs 
:load record.hs 
:load record.hs 
:load record.hs 
MkPerson "apple" 2
:load record.hs 
MkPerson "apple" 2
:load record.hs 
:load record.hs 
:load record.hs 
:load record.hs 
:t name
name 
:t MkEmp 
:t MkPerson 
b
b = MkPerson "apple"
show(a)
a
a
a = MkEmp "apple"
Emp
}
  name :: String
data Emp = MkEmp{
}
  name :: String
data Person = MkPerson{
}
 ,Age  :: Int
  name :: String
data Person = MkPerson{
:set +m
data Person = MkPerson 
data Person = MkPerson 
:type MkTE
:type MkTe
:MkTE
10 `subtract` 2
subtract 10 2
subtract 2 10
2 `subtract` 10
:info (->)
:k (->)
:i (->)
:i (<-)
:k (<-)
 a =\x -> x +1
\x -> x +1
:k (->)
:kind (->)
:type (->)
:}
twoArgumentFunction :: (->) Int ((->) Char Bool)
:{
:type absurd 
map absurd []
map absurd [1,2]
map absurd []
import Data.Void 
:t view a
a
a = Person "maqbool" "alam"
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
a
a = Person "maqbool" "alam"
:load Projects/playground/haskell/showPerson.hs 
a
a = Person "maqbool" "alam"
:load Projects/playground/haskell/showPerson.hs 
a
a = Person "maqbool" "alam"
:load Projects/playground/haskell/showPerson.hs 
a
a = Person "maqbool" "alam"
:load Projects/playground/haskell/showPerson.hs 
a
a = Person "maqbool" "alam"
Person "apple" "mango"
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
:load Projects/playground/haskell/showPerson.hs 
       first :: String 
data Person =  { 
