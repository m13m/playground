:t liftA2
import Control.Applicative
import List
:t liftA2
import Control.Monad
:t liftA2
:t liftA2
replicate 3 "ab"
replicate 3 'ab'
replicate 3 'a'
(let w = 'w' in [w,w,w])
)
(let w = 'w' in [w,w,w]_
(let x = 'w' in [x, 'o', x]) ++ "!"
(let x = 'w' in [x, 'o', x])
(let x = 'w' in [x, 'o', x]) ++ '!'
let x = 'w' in [x, 'o', x] ++ '!'
main
  putStrLn "Couting"
main = do
main :: IO ()
module Print2 where
:r 
:set prompt "Î»> "
multi2 
         y = 1000
   where x = 3
multi2 = x * 3 + y
module Mult2 where
mult1 
mult1 4
        y = 6
  where x = 5
mult1 = x * y
module Mult1 where
let x = 3; y = 6 in x * y
let x =  5 in x * x
let x = 5 in x
printINc2 4
              in print plusTwo
printINc2 n = let plusTwo = n + 2
module FunctionWithLet where 
printInc 4
   where plusTwo = n + 2
printInc n = print plusTwo
module FunctionWithWhere where
  where plusTwo = n + 2
printInc n = print plustwo
module Function where
area 2
:load chapter2.hs 
compose'' 4 
:load chapter2.hs 
compose'' 4
compose'' 4
:load chapter2.hs 
compose 4
:load chapter2.hs 
:load chapter2.hs 
half 2 + square 4
square 4
half 2
:load chapter2.hs 
half x  = x / 2
(1, 2 + 2 ) --WHNF
(\f -> (1, 2 +f) ) 2
1
:?
:save main.hs
:info (/)
:info ($)
:info ($_)
:info (+)
:info
square 4
square x = x * x
half 4
half x = x / 2
(\f -> (1, 2 + f)) 2
triple 4
triple x = x * 3
(1 + 2) * 2
sayHello maqbool
sayHello "maqbool"
:load chapter2.hs 
writeFile "aa aaa"
2 `div` 0
2 
:t forall
[c | x <- a]
a = [1,2,3]
:t when
mapM a print
mapM print a
forM a print
:t forM
:t mapM
forM a print
forM print a
mapM_ print a
mapM_ a print
import Control.Monad
mapM_ a print
mapM a print
a = [1,2,3]
[1,2,3]
return (-x)
print (x * x)
forM_ [1,3, 4] $ \x -> do
return (-x)
print (x * x)
forM [1,3, 4] $ \x -> do
return (-x)
print (x * x)
forM [1,3, 4] $ \x -> do
import Control.Monad 
mapM_ print ls
mapM_ print list
map print list
map (*2) list
mapM print list
mapM print value
:t print
:t ls
ls = [1,23]
;jkjsdfa
[
]
ls = [1,23[
:t list 
list = [X 1, Y "value", Z 1.2]
data Value = X Int | Y String | Z Float deriving(Show)
mapM_ print [1,2,3]
map print [1,2,3]
mapM print [1,2,3]
mapM_ [1,2,3]
mapM [1,2,3]
:t mapM
:t mapM_ 
Test "maqbool"
:k Test
data Test = Test String deriving(Show, Eq)
show black 
:t black 
black = RGB 255 255 255 
data Color = RGB Int Int Int  deriving (Show, Eq)
data Color = RGB Int Int Int
data Color = Color RGB Int Int Int
max (1, 2) 3
:set -XFlexibleContexts 
max (1, 2) 3
}
_ -> error "wrong value"
x -> sin x
let a = \x -> case x of {
}
6 -> sin 6
5 -> sin 5
\case 5 {
}
6 -> sin 6
5 -> sin 5
\case {
:set -XLambdaCase 
sin 5
8 -> 8
5 -> 5
case 2 + 3 of
}
3 -> 3 + 5
2 -> 2 + 3
\case {
:set -XLambdaCase 
}
3 -> 3 + 5
2 -> 2 + 3
\case {
:set -XEmptyCase 
\x  -> case x of { x }
\x  -> case x of {}
:k IArray
import Data.Array.IArray 
:k IArray
import Data.Array
:k IArray
:}
myfunc s  = read s
myFunc :: String -> Int
:{
myfunc "hello"
myfunc s  = read s
read "1" :: Int
:t zipWith
fibs !! 6
fibs !! 5
fibs !! 4
fibs !! 3
fibs !! 2
fibs !! 1
fibs !! 0
fibs !! 4
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
[1,2, 3] !! 2
[1,2, 3] !! 3
[1,2, 3] !! 0
[1,2, 3] !! 1
:t (!!)
t (!!)
fib 4
:}
        where fibs (a, b) = a : fibs (b, a+b)
fib n = fibs(0, 1) !! n
:{ 
fib n = fibs(0, 1) !! n
:t scanl
:hoogle [a] -> [[a]] -> [a]
:hoogle intercalate
  foldl' (*) 1 [1..6]
foldl' (*) 1 [1..6]
fold' (*) 1 [1..6]
:t fold'
fold' (*) 1 [1..6]
clear
fold' (*) 1 [1..6]
product [1..6]
intercalate ", " ["this", "is", "a", "comma"]
:t intercalate
import Data.List
:t intercalate
:t intercalate
:t concatMap 
:t flatten 
 > flatten (ListOfLists [List [1,2],List [3],ListOfLists [List [4],List[5]]])
ListOfLists [List[3], List [5]]
ListOfLists [List 3, List 5]
flatten [1,[2,3]]
:}
 flatten (ListOfLists xss) = concatMap flatten xss
 flatten (List xs) = xs
 flatten :: Lists a -> [a]
:{
:}
flatten (ListOfLists xss) = concatMap flatten xss
flatten (List xs) = xs
flatten :: List a -> [a]
:{
 data Lists a = List [a] | ListOfLists [Lists a]
:doc [[]] -> []
f 4 3
f a b = b a
:set -XRankNTypes 
g f 
g f 4
g f 
g 3
g k = k ()
f 23
f = \x  -> x
f 23 
f 23 2
f = \x _ -> x
swap (4,4)
swap (4, 4)
swap (4, 3)
swap (a, b) = (b, a)
:set +m
:k Data
import Data.Data
:k Data
:set -XDeriveDataTypeable
:k Data
:k DAta
:t String
String ['a']
String "hello"
String 
import Data.String 
putStrLn getCurrentTime 
:t getCurrentTime 
getCurrentTime 
import           Data.Time.Clock            (getCurrentTime)
length []
length [1,2,3]
length [] =  0 ; length (_:xs) = 1 + length(xs)
length [1,2,3]
length (_: xs) = 1 + length(xs)
length [] =  0
Cell 0 $ Cell 1
Cell 5 
Cell 5 (Nil )
data List a = Nil | Cell a (List a)
Nothing :: Maybe a
data Maybe a = Nothing | Just a
show false
false = False
data Bool = False | True deriving (Show)
data Bool = False | True
show a
a = Minutes 42
show Minutes 42
Minutes 4
data Minutes = Minutes Int deriving (Show)
data Minutes = Minutes Int
show none
none = None
data None = None deriving (Show)
none = None
data None = None
:t ($)
:t (.)
:t filter
:t map
:t Map
Map(4,3)
Map [(4, 3)]
[(4, 3)]
Map 
a = Map 4 3 
Map 4 3
type Map k v = [(k, v)]
:hoogle foldl
:doc foldl
foldl   0 [1,23,4]
foldl (\x -> x )  0 [1,23,4]
foldl 0 [1,23,4]
a 4
a
let a = fun $ 2
fun x y = x + y
a
let a = fun $ 2
a
let a = fun (2 + 3)
a
let a = fun $ 2 + 3
let a = fun $ x + y
fun x  = x + 1
let a = fun $ x + y
f 4
:t f
:}
f x = x
f :: Int -> Int 
:{
:t writer
:t write
:k WriteT
import Control.Monad.Writer
import mtl
:set -packge mtl
import Control.Monad.Writer
:set -packge mtl
import Control.Monad.Writer
import Control
putStrLn [1]
putStrLn []
print []
:t putStrLn
:t print
replicateM_ 10 $ print "hello, world"
replicateM_ 10 $ putStrLn "hello, world"
replicate 10 $  "hello, world"
replicate 1 $  "hello, world"
replicate 1 $ putStrLn "hello, world"
replicate 1 "hello, world"
:t replicate
replicateM_ 10 $ putStrLn "Hello, world!"
replicateM_ 1 $ putStrLn "Hello, world!"
:t replicateM_
import Control.Monad (replicateM_)
:t replicateM_
:h replicateM_
unwords $ replicate 2 "hellowrld\n"
unwords $ replicate 2 "hellowrld"
unwords $ replicate 2 "hellowrld" $ putStrLn
unwords $ replicate 2 "hellowrld"
printStrLn $ replicate 2 "hellowrld"
replicate 2 "hellowrld"
:t replicate
:t unwords
:tunwords
helloworld 5
helloworld n = putStrLn $ unwords $ replicate n "hello world\n"
putStrLn $ unwords $ replicate n "hello world\n"
putStrLn $ unwords $ replicate 4 "hi\n"
putStrLn $ unwords $ replicate 4 "hi"
    helloworld(n-1)
    print(n)
helloworld n when n > 0 = do
   helloworld(n-1)
   print(n)
helloworlds n  = do
foldl(\c -> c + 1) 
a = foldl(\c -> c + 1) 0
lengths = foldl' (\c _ -> c+1) 0
length' = foldl' (\c _ -> c+1) 0
    length = foldl' (\c _ -> c+1) 0
:t foldl
:t foldl'
:t foldl''
:t fold'
:t length
length [1,2,3]
len []
len [1,3,4]
    len(x:xs) = x +  len(xs)
let len [] = 0
:}
    len (x:xs) = x + len(xs)
let len [] = 0
len :: [a] -> Int
:{
:}
    len (x:y) = x + len(y) 
let len [] = 0
len :: [a] -> Int
:{
:}
    len (x:y) = x + len(y) 
let len [] = 0
len :: [a] -> Int
:{
len (x:y) = x + len(y) 
len [] = 0
len :: [a] -> Int
:t factorial
factorial
factorial 10
    factorial n = n * factorial(n-1)
let factorial 0 = 1
factorial n = n * factorial(n-1)
let factorial 0 = 1
factorial 0  = 1
:set +m
:set m
fact 4
:load main.hs 
:set -Wall
:load main.hs 
:t fact
fact 0
:load main.hs 
:load main.hs 
:set -Wall
fact 4
:set -Wtype-defaults 
fact 4
:load main.hs 
clear
:set -Wall
:load main.hs 
:set -Wall
:set -Wal
fact 3
fact 0
:load main.hs 
:load main.
fact 0 = 1
:set -Wall
fact 0
fact n = n * fact(n-1)
fact 0 = 1
fact 4
:k String 
:t "Ho"
:set -XOverloadedStrings 
clear
ls
:k Foldable 
:t length
import Network.HTTP.Types
import Network.Wai
import Network.Wai.Application.Static
import Network.Wai.Application.Static(staticApp, defaultWebSettings)
